---
layout: default
permalink: /2010/tasks/task1/
title: Задание №1. Анализатор изображений (2010)
---

# Задание №1. Анализатор изображений

Нужно написать программу, которая должна открывать изображение и показывать его каналы (в выбранной цветовой модели). Также в изображение некоторым способом (например, фильтрацией) могут вноситься изменения, поэтому одновременно с исходной картинкой нужно видеть ее измененный вариант. Для исходного и измененного изображений нужно вывести ряд числовых параметров.

Все изображения должны выводиться без искажений --- пиксель изображения соответствует пикселю на экране. Желательно показывать скролбары, если изображение целиком не помещается на экран.

Ключевые возможности:

* Загружать изображения в формате bmp (другие форматы по желанию)
* Показывать как всё изображение целиком, так и каждый его канал в отдельности для моделей:
  * [RGB]
  * [YUV] \(lossless и lossy, т.е. фактически это две модели\)
* Показывать исходное изображение или канал, а также его измененный вариант.
Изменения могут вноситься разными способами (например, фильтрами).
* Для исходного изображения выводить следующие параметры:
  * Ширина ($$width$$), высота ($$height$$) в пикселях
  * Площадь ($$area$$), равная $$width \times height$$
  * Количество бит на пиксель ($$\text{bits-per-pixel}$$ или $$bpp$$)
  * Размер ($$size$$), равный $$width \times height \times bpp / 8$$ в байтах
  * Энтропия ($$entropy$$) в битах
  * Размер по энтропии ($$\text{entropy-size}$$), равный $$width \times height \times entropy / 8$$ в байтах
  * Отношение ($$ratio$$), равное $$size / \text{entropy-size}$$
* Для модифицированного изображения:
  * Метрики MaxDiff, MinDiff, PSNR, RMS
  * Энтропия ($$entropy$$) в битах
  * Размер по энтропии ($$\text{entropy-size}$$), равный $$width \times height \times entropy / 8$$ в байтах
  * Отношение ($$ratio$$), равное $$size / \text{entropy-size}$$
В данном задании изменения в изображение вносятся двумя способами:
* Фильтр сглаживания (smooth) с регулировкой интенсивности от 0.0 (нет изменений) до 1.0 (сильное сглаживание)
* Фильтр резкости (sharp) с регулировкой интенсивности от 0.0 (нет изменений) до 1.0 (сильная резкость)

Фильтры реализуются самостоятельно любым удобным способом. При каждом запуске фильтр применяется относительно исходного изображения.

Полезно вывести гистограмму для каждого канала изображения, но это по желанию. Изображения, которые будут использоваться для тестирования можно найти [здесь][test-data].

Не нужно выводить каналы R,G,B в оттенках красного, зеленого или синего -- только в оттенках серого.

## Энтропия

Пусть вектор $$c$$ --- канал изображения, $$n_i$$ --- сколько раз значение $$i$$ встречается в векторе $$c$$ и $$p_i = n_i/\vert c \vert$$ --- вероятность. Энтропия $$c$$ вычисляется по следующей формуле:

$$
H(c) = -\sum {p_i}\log_2{p_i}
$$

Энтропия всего изображения --- сумма энтропий каждого канала.

## Метрики

Чтобы определить, насколько измененное изображение отличается от исходного, используются различные метрики. Пусть $$с_1$$ и $$с_2$$ -- каналы изображения в виде векторов длины $$n = width \cdot height$$:

* $$MaxDiff = \max_{i}\left\vert c_1[i] - c_2[i]\right\vert$$ -- максимальная разность
* $$MinDiff = \min_{i}\left\vert c_1[i] - c_2[i]\right\vert$$ -- минимальная разность
* $$RMS = \sqrt{\displaystyle\frac{1}{n}\sum_{i=1}^{n}{\left(c_1[i] - c_2[i]\right)^2}}$$ [Wikipedia][RMS]
* $$PSNR = 20\log_{10}\displaystyle\frac{MAX}{RMS}$$, где $$MAX$$ -- это максимальное значение в канале [Wikipedia][PSNR]

Значения метрик нужно вычислять только для каналов. Если выбрано все изображение, то нужно показывать значения метрик всех каналов.

## Преобразование RGB в YUV и обратно

### Без потерь

| RGB → YUV                                | YUV → RGB                                |
|------------------------------------------|------------------------------------------|
| $$u = r - g$$                            | $$g = y - \displaystyle\frac{u + v}{4}$$ |
| $$v = b - g$$                            | $$r = u + g$$                            |
| $$y = \displaystyle\frac{u + v}{4} + g$$ | $$b = v + g$$                            |


### С потерями

| RGB → YUV                             | YUV → RGB                          |
|---------------------------------------|------------------------------------|
|  y' = 0.299\*r + 0.587\*g + 0.114\*b  |                                    |
|  y = (int)y'                          |  b = clip(y + 1.770\*u)            |
|  u = (int)(0.565\*(b - y'))           |  g = clip(y - 0.344\*u - 0.714\*v) |
|  v = (int)(0.713\*(r - y'))           |  r = clip(y + 1.403\*v)            |

```
public static int clip(double value) {
    final int v = (int) Math.round(value);

    if (v < 0) {
        return 0;
    }

    if (v > 255) {
        return 255;
    }

    return v;
}
```

## Интерфейс

Внешний вид программы не является фиксированным. Возможная реализация приведена ниже. Любые полезные дополнения приветствуются.

![Main Window]({{site.baseurl}}/assets/content/image/tasks/task1/main-window.png)

Возможные пункты меню.

![Menus]({{site.baseurl}}/assets/content/image/tasks/task1/menus.png)

[test-data]: {{site.baseurl}}/info/test-data/
[RMS]: http://en.wikipedia.org/wiki/Root_mean_square
[PSNR]: http://en.wikipedia.org/wiki/PSNR
[RGB]: http://en.wikipedia.org/wiki/Rgb
[YUV]: http://en.wikipedia.org/wiki/Yuv
